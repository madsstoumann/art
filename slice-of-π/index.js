import * as common from '../common.js';
const GUI = document.querySelector('gui-control');
const storageKey = 'numbersequence';
const svg = document.getElementById('svg');

GUI.addRange('Gridsize', 4, '', { min: 2, max: 24, step: 2, name: 'gridsize' });
GUI.addSelect('Palette', 'Masonite Too', '', { 
  options: [
    { key: 'Bauhaus Originals', value: '#e47a2c #baccc0 #6c958f #40363f #d7a26c #ae4935 #f7e6d4 #c25528 #8b7756 #496b67 #745a63 #ebc096 #863625 #dfd1c5 #f09c5a #95b1a5 #305047 #231c21' }, 
    { key: 'Weimar Heritage', value: '#4f507d #aba59f #eba027 #1f1c16 #998a74 #e2471f #56704a #e2805f #686ca3 #7d7872 #d9870e #3a3832 #b3a590 #b8381a #3e513a #cd6748 #7a7ca5 #c5c0bd' },
    { key: 'Modernist Spectrum', value: '#D32F2F #1976D2 #FFC107 #388E3C #F57C00 #7B1FA2 #455A64 #FBC02D #9C1E1E #0D5AA0 #E6A800 #276C2C #BC6000 #5E1785 #2F3E45 #F59800 #E35C5C #42A5F5' },
    { key: 'Classic Bauhaus Tones', value: '#A63334 #3E5F8A #F2BF7C #7D807D #E7A95E #4C4B40 #83988E #D9C9A5 #7E2425 #294268 #E8A452 #5C5F5A #D99032 #2F2E24 #5C726A #C5AF7F #C25956 #6085B6' },
    { key: 'Dusty Weimar Shades', value: '#8D5A4A #526A82 #C4A981 #6A706E #B5803A #635D52 #A4B3A2 #CFC1A4 #6B4437 #3A4D5E #B09166 #515756 #94682D #47443C #7E8B7C #B9AA8B #AC7C6B #6E8CA9' },
    { key: 'Industrial Grays', value: '#6B6E70 #4B4F52 #919497 #2D2E30 #A6A8AB #3A3C3F #C1C3C5 #787A7C #55585A #33373A #7D8084 #1A1B1D #8D8F93 #25272A #D6D8DC #9B9EA1 #3F4143 #242629' },
    { key: 'Muted Blue', value: '#4A637D #6E8499 #98A9B5 #2F4A66 #5B7490 #7D92A6 #A3B3C0 #3E5C7A #374A5E #5D7185 #7D8D9A #223B54 #496179 #617992 #8E9DAA #2D4B6A #294057 #4C6279' },
    { key: 'Muted Terracotta', value: '#A2543A #B67F5E #D2A98A #8F6C5A #E8C3A6 #704B3E #C0876C #5A3D31 #7E4029 #9F6848 #C08C6B #6E5346 #D9AA8B #583B30 #A36F58 #442E25 #B36B50 #D4BDA4' },
    { key: 'Autumn Modernism', value: '#7F4E2A #9B7042 #C49973 #5D6A5B #A77A4A #8C5B39 #B89675 #6E553C #653D1F #8D5F30 #B78754 #485249 #986B3F #704828 #A48665 #584229 #AD693B #D5B99C' },
    { key: 'Vintage Pastels', value: '#9A7F6B #A99488 #D1B5AC #82746E #B2A196 #C7B8AE #E3D4CD #746258 #856A57 #968073 #C09E93 #665952 #A08E82 #B4A399 #D6C0B6 #5A4A42 #B59888 #DBD0C7' },
    { key: 'Olive & Ochre', value: '#5D5B39 #75744A #B3B077 #8A8558 #A39F6E #6E6C4D #D2CE98 #8F8D64 #49472C #626139 #9E9B66 #76724A #8A875A #5A593D #C4C080 #7A7752 #383625 #CECA8A' },
    { key: 'Pink Caviar', value: '#DDC09B #DDD8B9 #4B3985 #D96028 #3B0B04 #9F9C99 #437D3D #F7C945 #F3F0E7 #020003 #191B59 #A22017 #C9AD89 #BFBCA0 #362B61 #AE4F21 #5D0A06 #7C7976' },
    { key: 'Masonite', value: '#BB3331 #8A8D95 #F3D654 #882D2F #463781 #A16834 #47A2CD #C75C91 #E2713C #273D78 #999DA1 #DF6738 #885F54 #204E3E #D1C74C #2B6767 #8F2726 #74767D' },
    { key: 'Masonite Too', value: '#141414 #C13431 #3581C0 #2C674A #28638A #C74533 #66589F #E37242 #9594A1 #2A634A #7A8EAD #C4893D #244C94 #BB7142 #E9973E #D75235 #080808 #972825' }
  ], 
  name: 'palette'
});
GUI.addSelect('Sequence', 'Slice of π', '', {
  options: [
    { key: 'Slice of π', value: '314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317' },
    { key: 'Fibonacci', value: '112358132134558914423337761098725844181676510946177112865746368750251213931964183178115142298320401346269217830935245785702887126094032512250165151928897478437854703989122910051965867278193211653786132118177229408472232696486639235731764198371951311257591751881909167206840387201861033173315432892830454906217589741978497174177588419530941057903906576285138235386783099929324922716533734591226704174274156786645289535643842577633965982953765700684870633409153468256854270885199252633864527454627374822608457990687362151313429298535139894123891319877438722432280966353615825238' },
    { key: 'Euler\'s Number (e)', value: '271828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901157383418793070215408914993488416750924476146066808226480016847741185374234544243710753907774499206955170276183860626133138458300075204493382656029760673711320070932870912744374704723069697720931014169283681902551510865746377211125238978442505695369677078544996996794686445490598793163688923009879312773617821542499922957635148220826989519366803318252886939849646510582093923982948879332036250944311730123819706841614039701983767932068328237646480429531292905834574856698962661' },
    { key: 'Golden Ratio (φ)', value: '161803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475408807538689175212663386222353693179318006076672635443338908659593958290563832266131992829026788067520876689250171169620703222104321626954862629631361443814975870122034080588795445474924618569536486444924104432077134494704956584678850987433944221254487706647809158846074998871240076521705751797883416625624940758906970400028121042762177111777805315317141011704666599146697987317613560067087480710131795236894275219484353056783002287856997829778347845878228911097625003026961561700250464338243776486102838312683303724292675263116533924731671112115881490733430538204643541445464006352498302' },
    { key: 'Square Root of 2', value: '141421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147010955997160597027453459686201472851741864088919860955232923048430871432145083976260362799525140798968725339654633180882964062061525835239505474575028775996172983557522033753185701135437460340849884716038689997069900481503054402779031645424782306849293691862158057846311159666871301301561856898723724020731717452171223060353766750885686258446869893943887777452336418058457544824585628301826649659752263514045163305141267759817947698692678987121010505858632352356246795910412283362252538904' },
    { key: 'Tau (2π)', value: '628318530717958647692528676655900576839433879875021164194988918461563281257241799725606965068423413596429617302656461329418768921910116446345071881625696223490056820540387704221111928924589790986076392885762195133186689225695129646757356633054240381829129713384698069921549080893184106269720215567577779198321833338892116352977583099934038304449270849501649622118588204809621478172041399683717333981230569099082267962787163297621145778047975077841914699801147579378846873868557487959998512220031732533203308646042429511566502573379715465898930352844946519193514312627811513094468017626150037503335326997534663947187901815755711102965201559549882457280389331038561088686879328532837751438371760' }
  ],
  name: 'sequence'
});
GUI.addRange('Scale', 1, '', { min: 0, max: 2, step: 0.025, name: 'scale' });
common.commonConfig(GUI, '#FFFFFF');
GUI.addEventListener('gui-input', (event) => common.handleGuiEvent(event, svg, GUI, storageKey, sliceOfPi));
common.init(GUI, storageKey, []);

/* === MAIN FUNCTION === */

function sliceOfPi(svg, controls) {
  const { width, height } = common.getViewBox(svg);
  const palette = controls.palette.value.split(/\s+/);
  const sequence = controls.sequence.value;

  const colorMap = {};
  for (let digit = 1; digit <= 8; digit++) {
    colorMap[digit] = [palette[(digit-1) * 2], palette[(digit-1) * 2 + 1]];
  }

  // Special cases for 0 and 9
  colorMap[0] = [palette[17], palette[16]];
  colorMap[9] = [palette[17], palette[17]];

  const gridsize = controls.gridsize.valueAsNumber;
  const scale = controls.scale.valueAsNumber || 1;

  const cellSize = Math.min(width, height) / gridsize;
  const cols = Math.floor(width / cellSize);
  const rows = Math.floor(height / cellSize);
  const patternWidth = cellSize * cols;
  const patternHeight = cellSize * rows;
  const scaledPatternWidth = patternWidth * scale;
  const scaledPatternHeight = patternHeight * scale;

  const offsetX = (width - scaledPatternWidth) / 2;
  const offsetY = (height - scaledPatternHeight) / 2;
  svg.setAttribute('shape-rendering', 'crispEdges');

  // Generate pattern content
  let patternContent = '';
  const smallRectSize = cellSize / 3;
  
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      // Get digit for this cell from the selected sequence
      const position = row * cols + col;
      const digit = parseInt(sequence.charAt(position % sequence.length));
      const [colorOne, colorTwo] = colorMap[digit];
      
      // Base cell (background)
      patternContent += `<rect x="${col * cellSize}" y="${row * cellSize}" width="${cellSize}" height="${cellSize}" fill="${colorTwo}" shape-rendering="crispEdges" />`;
      
      // Handle digit 0 - fill with colorOne except for center square
      if (digit === 0) {
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            // Center square is at i=1, j=1
            const fillColor = (i === 1 && j === 1) ? colorTwo : colorOne;
            patternContent += `<rect x="${col * cellSize + j * smallRectSize}" y="${row * cellSize + i * smallRectSize}" width="${smallRectSize}" height="${smallRectSize}" fill="${fillColor}" shape-rendering="crispEdges" />`;
          }
        }
        continue;
      }
      
      // For digit 9, fill all small rectangles with colorOne
      if (digit === 9) {
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            patternContent += `<rect x="${col * cellSize + j * smallRectSize}" y="${row * cellSize + i * smallRectSize}" width="${smallRectSize}" height="${smallRectSize}" fill="${colorOne}" shape-rendering="crispEdges" />`;
          }
        }
        continue;
      }

      let remainingToFill = digit;
      for (let i = 0; i < 3 && remainingToFill > 0; i++) {
        for (let j = 0; j < 3 && remainingToFill > 0; j++) {
          const fillColor = remainingToFill > 0 ? colorOne : colorTwo;
          patternContent += `<rect x="${col * cellSize + j * smallRectSize}" y="${row * cellSize + i * smallRectSize}" width="${smallRectSize}" height="${smallRectSize}" fill="${fillColor}" shape-rendering="crispEdges" />`;
          remainingToFill--;
        }
      }
    }
  }

  svg.innerHTML = `
  <defs>
    <pattern id="squares" width="${patternWidth}" height="${patternHeight}" patternUnits="userSpaceOnUse" shape-rendering="crispEdges">
      ${patternContent}
    </pattern>
  </defs>
  <g transform="translate(${offsetX} ${offsetY}) scale(${scale})">
    <rect width="${patternWidth}" height="${patternHeight}" fill="url(#squares)" shape-rendering="crispEdges" />
  </g>`;
}
